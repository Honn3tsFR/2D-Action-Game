<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pure Dinguerie — Action Game</title>
<style>
  html,body{height:100%;margin:0;background:#0b0c10;color:#e6eef8;font-family:Inter, Roboto, Arial;}
  #gameWrap{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:12px;gap:12px}
  canvas{background:linear-gradient(180deg,#09101a,#07111a);width:960px;height:640px;max-width:calc(100vw - 24px);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);image-rendering:pixelated}
  .hud{display:flex;gap:12px;align-items:center}
  .panel{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;backdrop-filter:blur(4px)}
  button{background:#1b6cff;border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer}
  a{color:#9bd3ff}
  #overlay{max-width:960px;text-align:left}
</style>
</head>
<body>
<div id="gameWrap">
  <h1>Pure Dinguerie — Action Game</h1>
  <div class="hud">
    <div class="panel">Vagues: <span id="wave">0</span></div>
    <div class="panel">Score: <span id="score">0</span></div>
    <div class="panel">Vie: <span id="hp">0</span></div>
    <div class="panel">Multiplicateur: <span id="mult">1x</span></div>
    <div style="margin-left:8px"><button id="restartBtn">Relancer</button></div>
  </div>
  <canvas id="cv" width="960" height="640"></canvas>
  <div id="overlay">
    <p>Contrôles : <strong>WASD / flèches</strong> pour bouger, <strong>souris</strong> pour viser + clic ou <strong>ESPACE</strong> pour tirer. Sur mobile : toucher l'écran pour tirer et un joystick tactile s'affichera.</p>
    <p>But : survivre. Fusillade frénétique, vagues, boss, pouvoirs, shop entre vagues. C'est conçu pour être simple à lancer — ouvre ce fichier dans ton navigateur et joue.</p>
    <p>Astuce : ramasse les power-ups verts (rapid fire), bleus (bouclier) et jaunes (bombe).</p>
  </div>
</div>
<script>
// Pure Dinguerie - compact single-file action game
// Author: ChatGPT — code generated to be easily playable

// ---- Setup
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const state = {
  running:true,
  wave:0,
  score:0,
  combo:0,
  hp:100,
  maxHp:100,
  highScore: localStorage.getItem('pd_highscore')||0,
  paused:false,
  between:false,
  shop:false
};

const el = id => document.getElementById(id);
el('wave').textContent = state.wave;
el('score').textContent = state.score;
el('hp').textContent = state.hp;
el('mult').textContent = '1x';

// Input
const input = {left:false,right:false,up:false,down:false,fire:false,mouseX:W/2,mouseY:H/2};
addEventListener('keydown',e=>{if(e.key==='ArrowLeft'||e.key==='a')input.left=true;if(e.key==='ArrowRight'||e.key==='d')input.right=true;if(e.key==='ArrowUp'||e.key==='w')input.up=true;if(e.key==='ArrowDown'||e.key==='s')input.down=true;if(e.code==='Space')input.fire=true;});
addEventListener('keyup',e=>{if(e.key==='ArrowLeft'||e.key==='a')input.left=false;if(e.key==='ArrowRight'||e.key==='d')input.right=false;if(e.key==='ArrowUp'||e.key==='w')input.up=false;if(e.key==='ArrowDown'||e.key==='s')input.down=false;if(e.code==='Space')input.fire=false;});
canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect(); input.mouseX=(e.clientX-r.left)*(canvas.width/r.width); input.mouseY=(e.clientY-r.top)*(canvas.height/r.height);} );
canvas.addEventListener('mousedown',e=>{input.fire=true});
addEventListener('mouseup',e=>{input.fire=false});

// Touch simple fire + joystick emulation
canvas.addEventListener('touchstart',e=>{e.preventDefault(); const t=e.touches[0]; const r=canvas.getBoundingClientRect(); input.mouseX=(t.clientX-r.left)*(canvas.width/r.width); input.mouseY=(t.clientY-r.top)*(canvas.height/r.height); input.fire=true});
canvas.addEventListener('touchmove',e=>{e.preventDefault(); const t=e.touches[0]; const r=canvas.getBoundingClientRect(); input.mouseX=(t.clientX-r.left)*(canvas.width/r.width); input.mouseY=(t.clientY-r.top)*(canvas.height/r.height);});
canvas.addEventListener('touchend',e=>{input.fire=false});

// Audio using WebAudio (simple synths)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function sfx(freq, type='sine', time=0.05, vol=0.08){
  const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
  o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + time); o.stop(audioCtx.currentTime + time + 0.02);
}

// Entities
const player = {x:W/2,y:H/2, r:12, speed:260, reload:0, reloadMax:0.12, lives:1, shield:0, rapid:false, score:0, bombs:1};
const bullets=[];
const enemies=[];
const items=[];
const particles=[];
let lastTime=0;

// Helpers
function rand(a,b){return Math.random()*(b-a)+a}
function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy)}

// Spawn enemy types
function spawnEnemy(type){
  const x = Math.random()<0.5? -20 : W+20; const y = rand(40,H-40);
  if(type===1) enemies.push({x,y,r:10,hp:6,spd:80,ang:0,type:1,score:50});
  if(type===2) enemies.push({x,y,r:14,hp:20,spd:55,type:2,dir:(Math.random()<0.5?-1:1),angle:0,score:120});
  if(type===3) enemies.push({x:rand(40,W-40),y:-30,r:18,hp:45,spd:35,type:3,score:300,shotTimer:0});
}

// Particles
function makeParticles(x,y,col,count=12,spd=80){
  for(let i=0;i<count;i++){const a=rand(0,Math.PI*2); particles.push({x,y,vx:Math.cos(a)*rand(0,spd),vy:Math.sin(a)*rand(0,spd),life:rand(0.4,1.1),col});}
}

// Item spawn
function spawnItem(x,y,kind){items.push({x,y,r:8,kind,ttl:12});}

// Game loop
function update(dt){
  if(state.paused) return;
  // player movement
  let dx=0,dy=0; if(input.left)dx-=1; if(input.right)dx+=1; if(input.up)dy-=1; if(input.down)dy+=1;
  // keyboard + mouse slight aiming influence
  if(dx||dy){const len=Math.hypot(dx,dy); dx/=len; dy/=len; }
  player.x += dx * player.speed * dt; player.y += dy * player.speed * dt;
  // clamp
  player.x = Math.max(16,Math.min(W-16,player.x)); player.y = Math.max(16,Math.min(H-16,player.y));

  // rotation toward mouse
  player.aimAng = Math.atan2(input.mouseY - player.y, input.mouseX - player.x);

  // shooting
  player.reload -= dt;
  const canFire = player.reload <=0;
  let firePressed = input.fire;
  if(firePressed && canFire){
    shootBullet(player.x + Math.cos(player.aimAng)*player.r, player.y + Math.sin(player.aimAng)*player.r, player.aimAng);
    player.reload = player.rapid? player.reloadMax/3 : player.reloadMax;
    sfx(900, 'square', 0.06, 0.06);
  }

  // bullets
  for(let i=bullets.length-1;i>=0;i--){const b=bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt; if(b.life<=0 || b.x< -40 || b.x>W+40 || b.y<-40 || b.y>H+40) bullets.splice(i,1);} 

  // enemies
  for(let i=enemies.length-1;i>=0;i--){const e=enemies[i];
    // behavior by type
    if(e.type===1){ // kamikaze
      const ang = Math.atan2(player.y-e.y, player.x-e.x);
      e.x += Math.cos(ang)*e.spd*dt; e.y += Math.sin(ang)*e.spd*dt; }
    else if(e.type===2){ e.y += Math.sin(Date.now()/300 + i)*20*dt; e.x += (player.x>e.x?1:-1) * e.spd*dt; }
    else if(e.type===3){ // shooter
      e.y += e.spd*dt; e.shotTimer -= dt; if(e.shotTimer<=0){e.shotTimer=1.2; // shoot toward player
          const ang=Math.atan2(player.y-e.y, player.x-e.x); enemies.push({x:e.x,y:e.y,r:8,hp:6,spd:160,type:4,ang:ang,score:0,life:4}); sfx(400,'sine',0.06,0.05);
      }}
    // collision with player
    if(dist(e,player) < e.r + player.r){ if(player.shield>0){ player.shield -= 20; } else { state.hp -= 12; }
      makeParticles(e.x,e.y,'#ffcc66',10,120); enemies.splice(i,1);
      sfx(120,'sawtooth',0.12,0.14);
      continue;
    }
    // enemy hit by bullets
    for(let j=bullets.length-1;j>=0;j--){const b=bullets[j]; if(Math.hypot(b.x-e.x,b.y-e.y) < e.r + 4){ e.hp -= b.dmg; bullets.splice(j,1); makeParticles(b.x,b.y,'#fff',4,40); if(e.hp<=0){ state.score += e.score; state.combo++; state.score += Math.floor(state.combo*5); makeParticles(e.x,e.y,'#f55',18,160); // drop item chance
            if(Math.random()<0.22) spawnItem(e.x,e.y, ['rapid','shield','bomb'][Math.floor(Math.random()*3)] ); enemies.splice(i,1); sfx(240,'triangle',0.12,0.12); break; } else { sfx(720,'sine',0.04,0.04); } }}
  }

  // bullets of type 4 (enemy bullets)
  for(let i=enemies.length-1;i>=0;i--){const e=enemies[i]; if(e.type===4){ e.x += Math.cos(e.ang)*e.spd*dt; e.y += Math.sin(e.ang)*e.spd*dt; e.life -= dt; if(e.life<=0) enemies.splice(i,1); if(Math.hypot(e.x-player.x,e.y-player.y) < e.r + player.r){ if(player.shield>0) player.shield -= 14; else state.hp -= 16; makeParticles(player.x,player.y,'#ff8',10,80); enemies.splice(i,1); sfx(200,'sawtooth',0.06,0.14); } }}

  // items
  for(let i=items.length-1;i>=0;i--){const it=items[i]; it.ttl -= dt; if(Math.hypot(it.x-player.x,it.y-player.y) < it.r + player.r){ // pickup
      if(it.kind==='rapid'){ player.rapid=true; setTimeout(()=>player.rapid=false,8000); }
      if(it.kind==='shield'){ player.shield = Math.min(100, player.shield + 50); }
      if(it.kind==='bomb'){ player.bombs++; }
      items.splice(i,1); sfx(1200,'square',0.08,0.06);
    } else if(it.ttl<=0) items.splice(i,1); }

  // particles
  for(let i=particles.length-1;i>=0;i--){const p=particles[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; if(p.life<=0) particles.splice(i,1);} 

  // combos cooldown
  state.combo = Math.max(0, state.combo - dt*0.5);
  // wave management
  if(!state.between){
    if(enemies.length===0){ // next wave
      startNextWave();
    }
  }

  // dead?
  if(state.hp <= 0){ state.running=false; state.between=false; state.shop=false; sfx(80,'sawtooth',0.6,0.25); }

  // UI sync
  el('wave').textContent = state.wave;
  el('score').textContent = Math.floor(state.score);
  el('hp').textContent = Math.max(0,Math.floor(state.hp));
  el('mult').textContent = Math.max(1,Math.floor(1 + state.combo/4)) + 'x';
}

function shootBullet(x,y,ang){ bullets.push({x,y,vx:Math.cos(ang)*720,vy:Math.sin(ang)*720,life:1.4,dmg:10}); }

function startNextWave(){ state.between=true; state.wave++; // give brief shop/upgrade window
  // award bonus for surviving
  state.score += Math.floor(50 + state.wave*10 + state.combo*2);
  // spawn shop choices as simple overlay for 3 seconds
  setTimeout(()=>{
    // spawn enemies according to wave difficulty
    const count = Math.min(12, 3 + Math.floor(state.wave*1.4));
    for(let i=0;i<count;i++){ spawnEnemy( Math.random()<0.6?1 : (Math.random()<0.5?2:3) ); }
    // occasional boss
    if(state.wave % 6 === 0){ // boss
      enemies.push({x:W/2,y:-80,r:40,hp:200 + state.wave*40,spd:25,type:5,score:1200,shoot:0});
    }
    state.between=false;
  }, 900);
}

// render
function draw(){ ctx.clearRect(0,0,W,H);
  // background grid
  for(let y=0;y<H;y+=40){ ctx.globalAlpha=0.02; ctx.fillStyle='#99bbff'; ctx.fillRect(0,y+ (Date.now()/120 % 40),W,1); }
  ctx.globalAlpha=1;
  // player
  ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(player.aimAng || 0);
  // shadow
  ctx.beginPath(); ctx.ellipse(0,8,player.r*1.1,player.r*0.6,0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.fill();
  // body
  ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-8,8); ctx.lineTo(-8,-8); ctx.closePath(); ctx.fillStyle='#74f6ff'; ctx.fill();
  // cockpit
  ctx.beginPath(); ctx.arc(2,0,5,0,Math.PI*2); ctx.fillStyle='#092'; ctx.fill();
  ctx.restore();
  // shield
  if(player.shield>0){ ctx.beginPath(); ctx.arc(player.x,player.y,player.r+12*(player.shield/100),0,Math.PI*2); ctx.strokeStyle='rgba(120,200,255,0.16)'; ctx.lineWidth=6; ctx.stroke(); }

  // bullets
  bullets.forEach(b=>{ ctx.beginPath(); ctx.fillStyle='#ffd'; ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); });
  // enemies
  enemies.forEach(e=>{
    ctx.save(); ctx.translate(e.x,e.y);
    if(e.type===5){ // boss
      ctx.beginPath(); ctx.rect(-e.r,-e.r,e.r*2,e.r*2); ctx.fillStyle='#ff5577'; ctx.fill(); ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.fillRect(-e.r,-e.r,e.r*2*(e.hp/(200+state.wave*40)),6);
    } else {
      ctx.beginPath(); ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fillStyle = e.type===1? '#ff8866' : (e.type===2? '#ffd86b' : '#8fe'); ctx.fill();
      ctx.fillStyle='rgba(0,0,0,0.14)'; ctx.fillRect(-e.r, -e.r-10, e.r*2*(e.hp/(e.type===1?6:(e.type===2?20:45))),4);
    }
    ctx.restore();
  });
  // items
  items.forEach(it=>{ ctx.beginPath(); ctx.arc(it.x,it.y,it.r+2,0,Math.PI*2); ctx.fillStyle = it.kind==='rapid'? '#6ef' : (it.kind==='shield'? '#6f6' : '#ffcf66'); ctx.fill(); });
  // particles
  particles.forEach(p=>{ ctx.globalAlpha = Math.max(0, p.life); ctx.fillStyle = p.col; ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha = 1; });

  // HUD overlay inside canvas (cool effects)
  ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(8,8,220,64);
  ctx.fillStyle='#fff'; ctx.font='14px monospace'; ctx.fillText('HP:'+Math.floor(state.hp)+'  SH:'+Math.floor(player.shield)+'  B:'+player.bombs,16,28);
  ctx.fillText('Wave:'+state.wave+' Score:'+Math.floor(state.score),16,48);

  if(!state.running){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='36px sans-serif'; ctx.fillText('GAME OVER',W/2-110,H/2-20); ctx.font='18px sans-serif'; ctx.fillText('Clique sur Relancer pour rejouer',W/2-150,H/2+10); }
}

// loop
function loop(t){ if(!lastTime) lastTime=t; const dt = Math.min(0.034,(t-lastTime)/1000); lastTime=t; update(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// start
state.wave=0; state.score=0; state.hp=player.hp=100; player.x=W/2; player.y=H/2; player.reloadMax=0.12; startNextWave();

// restart button
el('restartBtn').addEventListener('click', ()=>{ state.running=true; state.wave=0; state.score=0; state.hp=100; player.shield=0; enemies.length=0; bullets.length=0; items.length=0; particles.length=0; player.bombs=1; startNextWave(); });

// simple click bomb
addEventListener('keydown',e=>{ if(e.key==='b'){ if(player.bombs>0){ player.bombs--; explode(); } } });
function explode(){ // big damage
  makeParticles(player.x,player.y,'#ffb',60,220); enemies.forEach((e,i)=>{ if(Math.hypot(e.x-player.x,e.y-player.y) < 260){ e.hp -= 80; if(e.hp<=0){ state.score+=e.score; enemies.splice(i,1); } }}); sfx(360,'sawtooth',0.4,0.2); }

// autosave highscore
setInterval(()=>{ if(state.score > state.highScore){ state.highScore = Math.floor(state.score); localStorage.setItem('pd_highscore', state.highScore); } }, 2000);

</script>
</body>
</html>
